#
# Copyright 2011 Red Hat, Inc.
#
# This software is licensed to you under the GNU General Public
# License as published by the Free Software Foundation; either version
# 2 of the License (GPLv2) or (at your option) any later version.
# There is NO WARRANTY for this software, express or implied,
# including the implied warranties of MERCHANTABILITY,
# NON-INFRINGEMENT, or FITNESS FOR A PARTICULAR PURPOSE. You should
# have received a copy of GPLv2 along with this software; if not, see
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.

module Katello
  module Notices

    # Generate a notice:
    #
    # notice:              The text to include
    # options:             Optional hash containing various optional parameters.  This includes:
    #
    #   level:               The type of notice to be generated.  Supported values include:
    #                        :message, :success (Default), :warning, :error
    #
    #   synchronous_request: true. if this notice is associated with an event where
    #                        the user would expect to receive a response immediately
    #                        as part of a response. This typically applies for events
    #                        involving things such as create, update and delete.
    #
    #                        IMPORTANT: If creating a synchronous request, the invocation of notice
    #                        must be from within a controller (i.e. not a model).
    #
    #   persist:             true, if this notice should be stored via ActiveRecord.
    #                        Note: this option only applies when synchronous_request is true.
    #
    #   list_items:          Array of items to include with the generated notice (text).  If included,
    #                        the array will be converted to a string (separated by newlines) and
    #                        concatenated with the notice text.  This is useful in scenarios where
    #                        there are several validation errors occur from a single form submit.
    #
    #   details:             String containing additional details.  This would typically be to store
    #                        information such as a stack trace that is in addition to the notice text.
    #
    #   request_type:        String representing the request/action this notice is associated with.  In the case
    #                        of notices generated by controllers, this option is not necessary; however,
    #                        if the notice is generated by a model, it should be provided.  The typical format
    #                        would be something like "controller"+"___"+"action" (e.g. "changesets___promote")
    #
    #   user:                the user to send the notifcation to.  If not set, User.current is used
    #
    def notice notice, options = {}

      current_user = options[:user] || User.current

      notice = "" if notice.nil?

      # set the defaults
      level = :success
      synchronous_request = true
      persist = true
      global = false
      details = nil
      request_type = nil

      # if the notice was generated by a request on a controller, retrieve the requested action
      if (self.respond_to?('params') and (!params.nil? and !params[:controller].nil?))
        request_type = requested_action
      end

      unless options.nil?
        level = options[:level] unless options[:level].nil?
        synchronous_request = options[:synchronous_request] unless options[:synchronous_request].nil?
        persist = options[:persist] unless options[:persist].nil?
        global = options[:global] unless options[:global].nil?
        details = options[:details] unless options[:details].nil?
        request_type = options[:request_type] unless options[:request_type].nil?
      end

      notice_dialog = build_notice(notice, options[:list_items], options[:include_class_name])

      notice_string = notice_dialog["notices"].join("<br />")
      if notice_dialog.has_key?("validation_errors")
        notice_string = notice_string + notice_dialog["validation_errors"].join("<br />")
      end

      if synchronous_request
        # On a sync request, the client should expect to receive a notification
        # immediately without polling.  In order to support this, we will send a flash
        # notice.
        if !details.nil?
          notice_dialog["notices"].push( _("#{self.class.helpers.link_to('Click here', notices_path)} for more details."))
        end

        flash[level] = notice_dialog.to_json

        if persist
          # create & store notice... but mark as 'viewed'
          new_notice = Notice.create(:text => notice_string, :details => details, :level => level, :global => global,
                                     :request_type => request_type, :user_notices => [UserNotice.new(:user => current_user)])

          unless new_notice.nil?
            user_notice = current_user.user_notices.where(:notice_id => new_notice.id).first
            unless user_notice.nil?
              user_notice.viewed = true
              user_notice.save!
            end
          end
        end
      else
        # On an async request, the client shouldn't expect to receive a notification
        # immediately. As a result, we'll store the notification and it will be
        # retrieved by the client on it's next polling interval.
        #
        # create & store notice... and mark as 'not viewed'
        Notice.create!(:text => notice_string, :details => details, :level => level, :global => global,
                       :request_type => request_type, :user_notices => [UserNotice.new(:user => current_user, :viewed=>false)])
      end

      return notice_dialog
    end

    def build_notice notice, list_items, error_class_name = nil
      items = { "notices" => [] }

      if notice.kind_of? Array
        notice.each do |item|
          handle_notice_type item, items
        end
      elsif notice.kind_of? String
        unless list_items.nil? or list_items.length == 0
          notice = notice + list_items.join("<br />")
        end
        items["notices"].push(notice)
      else
        handle_notice_type notice, items, error_class_name
      end
      return items
    end

    def handle_notice_type notice, items, error_class_name = nil
      if notice.kind_of? ActiveRecord::RecordInvalid
        items["validation_errors"] = notice.record.errors.full_messages.to_a.map do |er|
          if error_class_name
            error_class_name + " " + er
          else
            er
          end
        end
        return items
      elsif notice.kind_of? RestClient::InternalServerError
        items["notices"].push(notice.response)
        return items
      elsif notice.kind_of?(RuntimeError) || notice.kind_of?(StandardError)
        items["notices"].push(notice.message)
      else
        Rails.logger.error("Received unrecognized notice: " + notice.inspect)
        items["notices"].push(notice)
      end
    end
  end
end